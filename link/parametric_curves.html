<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <title>Parametric graphs</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.min.js"
        }
      }
    </script>

    <style>
      body {
        margin: 0;
        display: flex;
      }

      .progress-bar-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
      }

      #progress-bar {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50%;
      }

      label {
        position: absolute;
        top: 55%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
      }
    </style>
  </head>
  <body>
    <div class="progress-bar-container">
      <label id="progress-label" for="progress-bar">Loading...</label>
      <progress id="progress-bar" value="0" max="100"></progress>
    </div>
    <canvas id="canvas"></canvas>
    <script type="module">
      import * as THREE from "three";
      import Stats from "https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/controls/OrbitControls.js";
      import { Parser } from "https://cdn.jsdelivr.net/npm/expr-eval@2.0.2/+esm";

      const progressBar = document.getElementById("progress-bar");
      const progressLabel = document.getElementById("progress-label");

      const loadingManager = new THREE.LoadingManager();

      loadingManager.onLoad = function () {
        document.querySelector(".progress-bar-container").style.display =
          "none";
      };

      loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
        progressBar.value = (itemsLoaded / itemsTotal) * 100;
        progressLabel.textContent = `Loaded ${itemsLoaded} of ${itemsTotal} files.`;
      };

      loadingManager.onError = function (url) {
        console.log("There was an error loading " + url);
      };

      const gui = new dat.GUI();

      gui.width = 400;

      let width = window.innerWidth;
      let height = window.innerHeight;

      let canvas = document.getElementById("canvas");

      let renderer = new THREE.WebGLRenderer({ antialias: true, canvas });

      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      renderer.setPixelRatio(window.devicePixelRatio);

      renderer.setSize(width, height);

      const stats = new Stats();
      document.body.appendChild(stats.dom);
      let fov = 45;
      let camera = new THREE.PerspectiveCamera(fov, width / height, 0.1, 100);

      camera.position.set(0, 0, 5);

      let controls = new OrbitControls(camera, renderer.domElement);

      let distance = 70;
      let boundingHeight = Math.tan((fov * (Math.PI / 180)) / 2) * distance;
      let boundingWidth = boundingHeight * (width / height);

      controls.saveState();

      window.addEventListener("resize", () => {
        width = window.innerWidth;
        height = window.innerHeight;

        boundingHeight = Math.tan((fov * (Math.PI / 180)) / 2) * distance;
        boundingWidth = boundingHeight * (width / height);

        camera.aspect = width / height;

        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
      });

      let scene = new THREE.Scene();

      scene.background = new THREE.Color("#000");

      scene.add(camera);

      let clock = new THREE.Clock();

      const textureLoader = new THREE.TextureLoader(loadingManager);

      loadingManager.onLoad();

      // ==========================================================
      // ======================== Relevant Code ===================
      // ==========================================================
      const t_limit = 60;
      const base_points = 2000;

      let material = new THREE.ShaderMaterial({
        uniforms: {
          solid: { value: false },
          solid_color: { value: new THREE.Color("#ffffff") },
          opacity: { value: 1 },
        },
        vertexShader: `
            varying vec3 pos;

            void main() {
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);

              pos = position;
            }
            `,
        fragmentShader: `
            varying vec3 pos;
            uniform bool solid;
            uniform vec3 solid_color;
            uniform float opacity;

            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main() {
              vec3 vPos = (pos + 1.) * .5;
              
              float dist = distance(pos, vec3(0., 0., 0.));

              float alpha = opacity;

              if (solid) {
                gl_FragColor = vec4(solid_color, alpha);
              } else {
                vec3 color = hsv2rgb(vec3(dist, 1., 1.));
                gl_FragColor = vec4(color, alpha);
              }
            }
            `,
        transparent: true,
      });

      class ParametricCurve {
        constructor(
          { f, range, material, interpolate, interpolate_multiplier },
          ...params
        ) {
          this.f = f;
          this.range = range;
          this.interpolate = interpolate || false;
          this.interpolate_multiplier = interpolate_multiplier || 1;
          this.mesh = new THREE.Line(
            this.construct_geometry(params, true),
            material
          );
        }

        construct_geometry(params) {
          if (this.mesh && this.mesh.geometry) this.mesh.geometry.dispose();
          let points = new Array(this.range.steps);
          let steps = (this.range.end - this.range.start) / this.range.steps;

          let curve = null;

          if (steps === 0) return new THREE.BufferGeometry();

          for (
            let t = this.range.start, i = 0;
            t <= this.range.end;
            t += steps, i++
          ) {
            let point = new THREE.Vector3();
            for (let dim in this.f)
              if (this.f[dim] && Object.hasOwn(point, dim)) {
                point[dim] = this.f[dim](t, params);
                if (point[dim] === Infinity) point[dim] = 1000;
              }
            points[i] = point;
          }

          if (this.interpolate) {
            if (Object.keys(this.f).length === 2)
              curve = new THREE.SplineCurve(points);
            else if (Object.keys(this.f).length === 3) {
              curve = new THREE.CatmullRomCurve3(points);
              curve.curveType = "centripetal";
            }
            return new THREE.BufferGeometry().setFromPoints(
              curve.getPoints(
                Math.round(this.range.steps * this.interpolate_multiplier)
              )
            );
          } else {
            return new THREE.BufferGeometry().setFromPoints(points);
          }
        }

        recalculate(params) {
          try {
            this.mesh.geometry = this.construct_geometry(params);
            this.mesh.geometry.needsUpdate = true;
            return true;
          } catch (e) {
            return false;
          }
        }
      }

      let parametric_curve = new ParametricCurve(
        {
          f: {
            x: function (theta, t) {
              return Math.sin(theta * 2) * Math.cos(theta * (t - 1));
            },
            y: function (theta, t) {
              return Math.sin(theta) * Math.sin(theta * t);
            },
          },
          range: { start: 0, end: 2 * Math.PI, steps: base_points },
          material: material,
          interpolate: true,
          interpolate_multiplier: 1.5,
        },
        1
      );

      scene.add(parametric_curve.mesh);

      // ========================= SETTINGS =======================

      var current_x = "sin(p * 2) * cos(p * (t - 1))";
      var current_y = "sin(p) * sin(p * t)";
      var current_z = "0";

      const color_type = ["rgb", "hsv"];

      let settings = {
        x_fn: current_x,
        y_fn: current_y,
        z_fn: current_z,
        p: 1,
        normalize_color: true,
        color_type,
        c1: "sqrt(x * x + y * y + z * z)",
        c2: "1",
        c3: "1",
        a: "1",
        solid_color: "#ffffff",
        points: 2000,
        background: "#000000",
        interpolate_points: true,
        interpolate_multiplier: 1.5,
        reset_advanced: function () {
          settings.points = base_points;
          settings.interpolate_points = true;
          settings.interpolate_multiplier = 1.5;
          parametric_curve.range.steps = settings.points;
          parametric_curve.interpolate = settings.interpolate_points;
          parametric_curve.interpolate_multiplier =
            settings.interpolate_multiplier;
          parametric_curve.recalculate(settings.time);
        },
        animate: true,
        time: t_limit,
        speed_multiplier: 1,
        reset: function () {
          settings.animate = false;
          settings.time = t_limit;
          settings.speed_multiplier = 1;
          parametric_curve.recalculate(settings.time);
        },
        delete_curve: function () {},
        reset_camera: function () {
          controls.reset();
        },
        add_curve: function () {},
        export_ext: ["png", "webp", "svg", "jpg", "gif", "mp4"],
        transparent_background: false,
        export: function () {},
      };
      const p1 = gui.addFolder("Parametric 1");
      const functions = p1.addFolder("Functions");
      functions
        .add(settings, "x_fn")
        .name("x(p, t)")
        .onFinishChange(() => {
          try {
            parametric_curve.f.x = Parser.parse(settings.x_fn).toJSFunction([
              "p",
              "t",
            ]);
            if (!parametric_curve.recalculate(settings.time)) throw new Error();
            current_x = settings.x_fn;
          } catch (e) {
            settings.x_fn = current_x;
          }
        });
      functions
        .add(settings, "y_fn")
        .name("y(p, t)")
        .onFinishChange(() => {
          try {
            parametric_curve.f.y = Parser.parse(settings.y_fn).toJSFunction([
              "p",
              "t",
            ]);
            if (!parametric_curve.recalculate(settings.time)) throw new Error();
            current_y = settings.y_fn;
          } catch (e) {
            settings.y_fn = current_y;
          }
        });
      functions
        .add(settings, "z_fn")
        .name("z(p, t)")
        .onFinishChange(() => {
          try {
            parametric_curve.f.z = Parser.parse(settings.z_fn).toJSFunction([
              "p",
              "t",
            ]);
            if (!parametric_curve.recalculate(settings.time)) throw new Error();
            current_z = settings.z_fn;
          } catch (e) {
            settings.z_fn = current_z;
          }
        });
      functions.open();
      const parameters = p1.addFolder("Parameters (WIP)");
      parameters
        .add(settings, "p", 0, 1, 0.001)
        .name("P")
        .onChange(() => {
          parametric_curve.range.end = 2 * Math.PI * settings.p;
          parametric_curve.recalculate(settings.time);
        });
      const color = p1.addFolder("Color (WIP)");
      color
        .add(settings, "normalize_color", settings.normalize_color)
        .name("Normalize Color (WIP)");
      color
        .add(settings, "color_type", settings.color_type)
        .name("Color Type (WIP)")
        .setValue(color_type[1])
        .onChange((value) => {
          if (value === color_type[0]) {
            c1.name("R(x, y, z, t) (WIP)");
            c2.name("G(x, y, z, t) (WIP)");
            c3.name("B(x, y, z, t) (WIP)");
          } else if (value === color_type[1]) {
            c1.name("H(x, y, z, t) (WIP)");
            c2.name("S(x, y, z, t) (WIP)");
            c3.name("V(x, y, z, t) (WIP)");
          }
        });
      const c1 = color
        .add(settings, "c1")
        .name("H(x, y, z, t) (WIP)")
        .onFinishChange((value) => {
          material.uniforms.solid.value = false;
        });
      const c2 = color
        .add(settings, "c2")
        .name("S(x, y, z, t) (WIP)")
        .onFinishChange((value) => {
          material.uniforms.solid.value = false;
        });
      const c3 = color
        .add(settings, "c3")
        .name("V(x, y, z, t) (WIP)")
        .onFinishChange((value) => {
          material.uniforms.solid.value = false;
        });
      color
        .add(settings, "a")
        .name("A(x, y, z, t) (WIP)")
        .onFinishChange((value) => {
          material.uniforms.solid.value = false;
        });
      color
        .addColor(settings, "solid_color")
        .name("Solid Color")
        .onChange((value) => {
          material.uniforms.solid.value = true;
          material.uniforms.solid_color.value = new THREE.Color(value);
        });
      const animation = p1.addFolder("Animation");
      animation.add(settings, "animate").name("Animate");
      animation
        .add(settings, "speed_multiplier", 0, 10, 0.01)
        .name("Speed Multiplier");
      animation
        .add(settings, "time", 0, t_limit, 0.01)
        .name("Time")
        .onChange(() => {
          parametric_curve.recalculate(settings.time);
        });
      animation.add(settings, "reset").name("Reset");
      animation.open();
      const advanced = p1.addFolder("Advanced");
      advanced
        .add(settings, "points", 100, 10000, 1)
        .name("Points")
        .onChange(() => {
          parametric_curve.range.steps = settings.points;
          parametric_curve.recalculate(settings.time);
        });
      advanced
        .add(settings, "interpolate_points")
        .name("Interpolate Points")
        .onChange(() => {
          parametric_curve.interpolate = settings.interpolate_points;
          parametric_curve.recalculate(settings.time);
        });
      advanced
        .add(settings, "interpolate_multiplier", 1.1, 10, 0.1)
        .name("Interpolate Multiplier")
        .onChange(() => {
          parametric_curve.interpolate_multiplier =
            settings.interpolate_multiplier;
          parametric_curve.recalculate(settings.time);
        });
      advanced.add(settings, "reset_advanced").name("Reset");
      p1.add(settings, "delete_curve").name("Delete Curve (WIP)");
      p1.open();
      const general = gui.addFolder("General");
      general.add(settings, "add_curve").name("Add Curve (WIP)");
      general.add(settings, "reset_camera").name("Reset Camera");
      general.addColor(settings, "background").name("Background");
      const exp = gui.addFolder("Export (WIP)");
      exp
        .add(settings, "export_ext", settings.export_ext)
        .name("Extension (WIP)")
        .setValue("png");
      exp
        .add(settings, "transparent_background")
        .name("Transparent Background (WIP)");
      exp.add(settings, "export").name("Export (WIP)");
      general.open();

      // ==========================================================

      function update(delta) {
        if (settings.animate) {
          settings.time += delta * settings.speed_multiplier;
          if (settings.time > t_limit) settings.time = 0;
        }
        gui.updateDisplay();
        stats.update();
      }

      // ==========================================================
      // ======================== End Relevant Code ===============
      // ==========================================================

      function render() {
        scene.background = new THREE.Color(settings.background);
        if (settings.animate) {
          try {
            parametric_curve.mesh.geometry =
              parametric_curve.construct_geometry(settings.time);
            parametric_curve.mesh.geometry.needsUpdate = true;
          } catch (e) {
            settings.x_fn = current_x;
            settings.y_fn = current_y;
            settings.z_fn = current_z;
            parametric_curve.f.x = Parser.parse(settings.x_fn).toJSFunction([
              "p",
              "t",
            ]);
            parametric_curve.f.y = Parser.parse(settings.y_fn).toJSFunction([
              "p",
              "t",
            ]);
            parametric_curve.f.z = Parser.parse(settings.z_fn).toJSFunction([
              "p",
              "t",
            ]);
            parametric_curve.recalculate(settings.time);
          }
        }
        renderer.render(scene, camera);
      }

      function animate() {
        let delta = clock.getDelta();
        render();
        update(delta);
        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>
